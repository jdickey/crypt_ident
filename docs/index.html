<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README
  
    &mdash; crypt_ident Module Documentation
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "README";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1>CryptIdent</h1>

<p>Yet another fairly basic authentication Gem. (Authorisation, and batteries, sold separately.)</p>

<p>This is initially tied to Hanami 1.3.0+; specifically, it assumes that user entities have an API compatible with <code>Hanami::Entity</code> for accessing the field/attribute values listed below in <a href="#databaserepository-setup"><em>Database/Repository Setup</em></a> (which itself assumes a Repository API compatible with that of Hanami 1.3&#39;s Repository classes). The Gem is mostly a thin layer around <a href="https://github.com/codahale/bcrypt-ruby">BCrypt</a> that, in conjunction with Hanami entities or work-alikes, supports the most common use cases for password-based authentication:</p>

<ol>
<li><a href="#registration">Registration</a>;</li>
<li><a href="#signing-in">Signing in</a>;</li>
<li><a href="#signing-out">Signing out</a>;</li>
<li><a href="#password-change">Password change</a>;</li>
<li><a href="#password-reset">Password reset</a>; and</li>
<li><a href="#session-management-overview">Session expiration management</a>.</li>
</ol>

<p>It <em>does not</em> implement features such as</p>

<ol>
<li>Password-strength testing;</li>
<li>Password occurrence in a <a href="https://www.passwordrandom.com/most-popular-passwords">list of most popular (and easily hacked) passwords</a>; or</li>
<li>Password ageing (requiring password changes after a period of time).</li>
</ol>

<p>These either violate current best-practice recommendations from security leaders (e.g., NIST and others no longer recommend password ageing as a defence against cracking) or have other Gems that focus on the features in question (e.g., <a href="https://github.com/bdmac/strong_password"><code>bdmac/strong_password</code></a>).</p>

<h1>Installation</h1>

<p>Add this line to your application&#39;s Gemfile:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>crypt_ident</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<p>And then execute:</p>

<pre class="code ruby"><code class="ruby">$ bundle
</code></pre>

<p>Or install it yourself as:</p>

<pre class="code ruby"><code class="ruby">$ gem install crypt_ident
</code></pre>

<h1>Usage</h1>

<h2>Database/Repository Setup</h2>

<p><code>CryptIdent</code> assumes that the repository used to read and update the underlying database table is named <code>UserRepository</code>; that can be changed using the <a href="#configuration"><em>Configuration</em></a> settings.</p>

<p>We further assume that the Repository object</p>

<ol>
<li>Has a <em>class method</em> named <code>.entity_name</code> that returns the name of the Entity used by that Repository <em>as a string</em> (e.g., <code>&quot;User&quot;</code> for a <code>UserRepository</code>);</li>
<li>Has a class method named <code>.guest_user</code> that returns an Entity with a descriptive name (e.g., &quot;Guest User&quot;) and is otherwise invalid for persistence (e.g., it has an invalid <code>id</code> attribute); and</li>
<li>Implements the &quot;usual&quot; common methods (<code>#create</code>, <code>#update</code>, <code>#delete</code>, etc) conforming to an interface compatible with <a href="https://github.com/hanami/model/blob/master/lib/hanami/repository.rb"><code>Hanami::Repository</code></a>. This interface is suitably generic and sufficiently widely implemented, even in ORMs such as ActiveRecord that make no claim to implementing the <a href="https://8thlight.com/blog/mike-ebert/2013/03/23/the-repository-pattern.html">Repository Pattern</a>.</li>
</ol>

<p>The database table for that Repository <strong>must</strong> have the following fields, in any order within the schema:</p>

<table><thead>
<tr>
<th style="text-align: left">Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>name</code></td>
<td>string</td>
<td>The name of an individual User to be Authenticated</td>
</tr>
<tr>
<td style="text-align: left"><code>email</code></td>
<td>string</td>
<td>The Email Address for that User, to be used for Password Recovery, for example.</td>
</tr>
<tr>
<td style="text-align: left"><code>password_hash</code></td>
<td>text</td>
<td>The <em>encrypted</em> Password associated with that User.</td>
</tr>
<tr>
<td style="text-align: left"><code>password_reset_expires_at</code></td>
<td>timestamp without time zone</td>
<td>Defaults to <code>nil</code>; set this to the Expiry Time (<code>Time.now + config.reset_expiry</code>) when responding to a Password Reset request (e.g., by email). The <code>token</code> (below) will expire at this time (see <em>Configuration</em>, below).</td>
</tr>
<tr>
<td style="text-align: left"><code>token</code></td>
<td>text</td>
<td>Defaults to <code>nil</code>. A Password Reset Token; a URL-safe secure random number (see <a href="https://ruby-doc.org/stdlib-2.5.1/libdoc/securerandom/rdoc/Random/Formatter.html#method-i-urlsafe_base64">standard-library documentation</a>) used to uniquely identify a Password Reset request.</td>
</tr>
</tbody></table>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h2>Configuration</h2>

<p>The currently-configurable details for <code>CryptIdent</code> are as follows:</p>

<table><thead>
<tr>
<th style="text-align: left">Key</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left"><code>error_key</code></td>
<td><code>:error</code></td>
<td>Modify this setting if you want to use a different key for flash messages reporting unsuccessful actions.</td>
</tr>
<tr>
<td style="text-align: left"><code>guest_user</code></td>
<td>Return value from <code>repository</code> <code>.guest_user</code> method</td>
<td>This value is used for the session variable <code>session[:current_user]</code> when no User has <a href="#signing-in">signed in</a>, or after a previously Authenticated User has <a href="#signing-out">signed out</a>. If your application <em>does not</em> make use of the <a href="https://en.wikipedia.org/wiki/Null_object_pattern">Null Object pattern</a>, you would assign <code>nil</code> to this configuration setting. (See <a href="https://robots.thoughtbot.com/rails-refactoring-example-introduce-null-object">this Thoughtbot post</a> for a good discussion of Null Objects in Ruby.)</td>
</tr>
<tr>
<td style="text-align: left"><code>hashing_cost</code></td>
<td>8</td>
<td>This is the <a href="https://github.com/codahale/bcrypt-ruby#cost-factors">hashing cost</a> used to <em>encrypt a password</em> and is applied at the hashed-password-creation step; it <strong>does not</strong> modify the default cost for the encryption engine. <strong>Note that</strong> any change to this value <strong>will</strong> invalidate and make useless all existing Encrypted Password stored values.</td>
</tr>
<tr>
<td style="text-align: left"><code>:repository</code></td>
<td><code>UserRepository.new</code></td>
<td>Modify this if your user records are in a different (or namespaced) class.</td>
</tr>
<tr>
<td style="text-align: left"><code>:reset_expiry</code></td>
<td>86400</td>
<td>Number of seconds from the time a password-reset request token is stored before it becomes invalid.</td>
</tr>
<tr>
<td style="text-align: left"><code>:session_expiry</code></td>
<td>900</td>
<td>Number of seconds <em>from either</em> the time that a User is successfully Authenticated <em>or</em> the <code>update_session_expiry</code> method is called <em>before</em> a call to <code>session_expired?</code> will return <code>true</code>.</td>
</tr>
<tr>
<td style="text-align: left"><code>:success_key</code></td>
<td><code>:success</code></td>
<td>Modify this setting if you want to use a different key for flash messages reporting successful actions.</td>
</tr>
<tr>
<td style="text-align: left"><code>:token_bytes</code></td>
<td>16</td>
<td>Number of bytes of random data to generate when building a password-reset token. See <code>token</code> in the <a href="#databaserepository-setup"><em>Database/Repository Setup</em></a> section, above.</td>
</tr>
</tbody></table>

<p>For example</p>

<pre class="code ruby"><code class="ruby">  <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="CryptIdent.html" title="CryptIdent (module)">CryptIdent</a></span></span>
  <span class='const'><span class='object_link'><a href="CryptIdent.html" title="CryptIdent (module)">CryptIdent</a></span></span><span class='period'>.</span><span class='id identifier rubyid_configure_crypt_id'>configure_crypt_id</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_config'>config</span><span class='op'>|</span>
    <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_repository'>repository</span> <span class='op'>=</span> <span class='const'>MainApp</span><span class='op'>::</span><span class='const'>Repositories</span><span class='op'>::</span><span class='const'>User</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='comment'># note: *not* a Hanami recommended practice!
</span>    <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_error_key'>error_key</span> <span class='op'>=</span> <span class='symbol'>:alert</span>
    <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_hashing_cost'>hashing_cost</span> <span class='op'>=</span> <span class='int'>6</span> <span class='comment'># less secure and less resource-intensive
</span>    <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_token_bytes'>token_bytes</span> <span class='op'>=</span> <span class='int'>20</span>
    <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_reset_expiry'>reset_expiry</span> <span class='op'>=</span> <span class='int'>7200</span> <span class='comment'># two hours; &quot;we run a tight ship here&quot;
</span>    <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_guest_user'>guest_user</span> <span class='op'>=</span> <span class='const'>UserRepository</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_guest_user'>guest_user</span>
  <span class='kw'>end</span>
</code></pre>

<p>would change the configuration as you would expect whenever that code was run. (We <strong>recommend</strong> that this be done inside the <code>controller.prepare</code> block of your Hanami <code>web</code> (or equivalent) app&#39;s <code>application.rb</code> file.)</p>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h2>Introductory Notes on Workflows</h2>

<h3>Interfaces</h3>

<p>The methods employed directly by these use cases use <a href="https://dry-rb.org/gems/dry-matcher/result-matcher/">Result matchers</a> and <a href="https://dry-rb.org/gems/dry-monads/1.0/result/"><code>Result</code> monads</a> to provide a <em>consistent, fluent, explicit, and understandable</em> mechanism for detecting and handling success and failure.</p>

<p>Each method <em>requires</em> a block, to which a <code>result</code> indicating success or failure is yielded. That block <strong>must</strong> in turn call <strong>both</strong> <code>result.success</code> and <code>result.failure</code> to handle success and failure results, respectively. Each of the two blocks takes parameters which the method uses to communicate either the successful result (and possible supporting information like the active configuration), or the reason for failure, along with supporting information. Not all failure cases use all parameters to the <code>result.failure</code> block. Any that are not relevant may be safely ignored (and <strong>should</strong> by convention have a value of <code>:unassigned</code> yielded to the <code>result.failure</code> block).</p>

<p>For further discussion of this, see the documentation of the individual methods in the <a href="docs/CryptIdent.html">API Reference</a>.</p>

<h3>Session Handling Not Automatic</h3>

<p>If you&#39;ve set up your <code>controller.prepare</code> block as <strong>recommended</strong> in the preceding section, <code>CryptIdent</code> is loaded and configured but <em>does not</em> implement session-handling &quot;out of the box&quot;; as with <a href="https://github.com/sebastjan-hribar/tachiban#session-handling">other libraries</a>, it must be implemented <em>by you</em> as described in the <a href="#session-expiration"><em>Session Expiration</em></a> description below.</p>

<h3>Code Samples in API Reference are Authoritative</h3>

<p>Only minimal code snippets are included here to help explain use cases.  However, the <a href="docs/CryptIdent.html">API Reference</a> should be considered authoritative; any discrepancies between the API and/or code snippets there and here should be regarded as a bug (and a <a href="https://github.com/jdickey/crypt_ident/issues/">report</a> filed if not already filed.</p>

<h3>Terminology and the project Ubiquitous Language</h3>

<p>Finally, a note on terminology. Terms that have meaning (e.g., <em>Guest User</em>) within this module&#39;s domain language, or <a href="https://www.martinfowler.com/bliki/UbiquitousLanguage.html">Ubiquitous Language</a>, <strong>must</strong> be capitalised, at least on first use within a paragraph. This is to stress to the reader that, while these terms may have &quot;obvious&quot; meanings, their use within this module and its related documents (including this one) <strong>should</strong> be consistent, specific, and rigorous in their meaning. In the <a href="docs/CryptIdent.html">API Documentation</a>, each of these terms <strong>must</strong> be listed in the <em>Ubiquitous Language Terms</em> section under each method description in which they are used.</p>

<p>After the first usage in a paragraph, the term <strong>may</strong> be used less strictly; e.g., by referring to a <em>Clear-Text Password</em> simply as a <em>password</em> <em>if</em> doing so does not introduce ambiguity or confusion. The reader should feel free to <a href="https://github.com/jdickey/cript_ident/issues">open an issue report</a> for any lapses of consistency or clarity. (Thank you!)</p>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h2>Use-Case Workflows</h2>

<h3>Registration</h3>

<h4>Overview</h4>

<p>Method involved:</p>

<pre class="code ruby"><code class="ruby">  <span class='kw'>module</span> <span class='const'><span class='object_link'><a href="CryptIdent.html" title="CryptIdent (module)">CryptIdent</a></span></span>
    <span class='kw'>def</span> <span class='id identifier rubyid_sign_up'>sign_up</span><span class='lparen'>(</span><span class='id identifier rubyid_attribs'>attribs</span><span class='comma'>,</span> <span class='label'>current_user:</span><span class='comma'>,</span> <span class='label'>repo:</span> <span class='kw'>nil</span><span class='rparen'>)</span>
      <span class='comment'># ...
</span>    <span class='kw'>end</span>
  <span class='kw'>end</span>
</code></pre>

<p>This is the first of our use cases that involves calling a function which expects a block to be supplied; if one isn&#39;t, then a log-format warning message will remind you of the error.</p>

<p>The <code>attribs</code> parameter is a Hash-like object such as a <code>Hanami::Action::Params</code> instance. It <strong>must</strong> have a <code>:name</code> entry, as well as any other keys and matching field values required by the Entity which will be created from the <code>params</code> values, <em>other than</em> a <code>:password_hash</code> key. It also <strong>must not</strong> have a <code>:password</code> entry; if one is supplied, it will be <em>ignored</em>. This is to support our <strong>recommended</strong> workflow of having newly-Registered Users be initially assigned a Clear-Text Password of random text, then immediately starting the <a href="#password-reset">Password Reset</a> workflow to further validate their supplied email address.</p>

<p>Pass in the value of the <code>session[:current_user]</code> session variable as the <code>:current_user</code> parameter. This <strong>must</strong> be an Entity value rather than an <code>id</code> value.</p>

<p>If a Repository instance different than that loaded by the <a href="#configuration"><em>Configuration</em></a> is to be used, pass it in as the <code>repo:</code> parameter. Leaving the default value, <code>nil</code>, <strong>should</strong> work in a properly-designed application.</p>

<p>As described <a href="#interfaces">earlier</a>, this method <strong>requires</strong> a block which accepts a <code>result</code> parameter. The block <strong>must</strong> call <em>both</em> the <code>result.success</code> and <code>result.failure</code> methods, passing each a block which itself takes appropriate parameters. These will be further described below.</p>

<h4>Success, aka Golden Path</h4>

<p>If the <code>params</code> include all values required by the underlying schema, including a valid <code>name</code> attribute that does not exist in the underlying data store, then it (with a <code>password_hash</code> attribute created from a random-text Clear-Text Password) will be persisted to the Repository specified by <code>repo:</code> (or to the Repository specified by the <a href="#configuratino"><em>Configuration</em></a> if the <code>repo:</code> value is <code>nil</code>).</p>

<p>That User Entity will be passed to the <code>result.success</code> block as the <code>user:</code> parameter. The active Configuration used will be passed to the block as the <code>config:</code> parameter. This will include a <code>:repository</code> instance which will be the default Repository (if <code>nil</code> was used as <code>#sign_up</code>&#39;s <code>repo:</code> parameter) or the specified Repository. Other possibly useful Configuration items include the <code>:success_key</code>, used to assign a &quot;success&quot; Flash message.</p>

<h4>Error Conditions</h4>

<h5>Authenticated User as <code>current_user:</code> Parameter</h5>

<p>If the specified <code>current_user:</code> parameter is a valid User Entity, then that is presumed to be the Current User of the application. Authenticated Users are prohibited from creating other Users, and so the <code>result.failure</code> block will be called with a <code>code:</code> of <code>:current_user_exists</code>, as well as a <code>config:</code> value that might be useful for its <code>:error_key</code> value.</p>

<h5>Specified <code>:name</code> Attribute Already Used for an Existing User</h5>

<p>If the specified <code>:name</code> attribute exists in a record within the Repository, then the <code>result.failure</code> block will be called with a <code>:code</code> of <code>:user_already_created</code>, as well as a <code>config:</code> value that might be useful for its <code>:error_key</code> value.</p>

<h5>Record Could Not be Created Within Repository</h5>

<p>If the Repository method <code>#create</code> returned an error, then the <code>result.failure</code> block will be called with a <code>:code</code> of <code>:user_creation_failed</code>, as well as a <code>config:</code> value that might be useful for its <code>:error_key</code> value.</p>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h3>Signing In</h3>

<h4>Overview</h4>

<p>Method involved:</p>

<pre class="code ruby"><code class="ruby">  <span class='kw'>module</span> <span class='const'><span class='object_link'><a href="CryptIdent.html" title="CryptIdent (module)">CryptIdent</a></span></span>
    <span class='kw'>def</span> <span class='id identifier rubyid_sign_in'>sign_in</span><span class='lparen'>(</span><span class='id identifier rubyid_user'>user</span><span class='comma'>,</span> <span class='id identifier rubyid_password'>password</span><span class='comma'>,</span> <span class='label'>current_user:</span> <span class='kw'>nil</span><span class='rparen'>)</span>
      <span class='comment'># ...
</span>    <span class='kw'>end</span>
  <span class='kw'>end</span>
</code></pre>

<p>Once a User has been <a href="#registration">Registered</a>, Signing In is a matter of retrieving that user&#39;s Entity (containing a <code>password_hash</code> attribute) and calling <code>#sign_in</code> passing in that Entity, the purported Clear-Text Password, and the currently Authenticated User (if any), then using the <code>result</code> passed to the yielded block to determine and respond to the success or failure of the call.</p>

<h4>Successfully Signing In</h4>

<p>So long as no User is currently Authenticated in the Session (as shown by the <code>session[:current_user]</code> having a value of either <code>nil</code> or the Guest User), supplying a User Entity and the correct Clear-Text Password for that User to a call to <code>#sign_in</code> will cause the block for the <code>#sign_in</code> method call to yield the <em>same</em> User Entity to the <code>result.success</code> block, indicating success.</p>

<p>Note that this process is unchanged if the passed-in <code>current_user</code> is <em>the same as</em> the User Entity attempting Authentication. It is up to client code to determine how to proceed if Authentication fails in this case.</p>

<h4>Error Conditions</h4>

<h5>Incorrect Password Supplied</h5>

<p>While no Authenticated Member currently exists (as shown by the <code>session[:current_user]</code> having a value of either <code>nil</code> or the Guest User), supplying a User Entity and an <em>incorrect</em> Clear-Text Password for that User to a call to <code>#sign_in</code> will yield a call to the block&#39;s <code>result.failure</code> block with a <code>code:</code> of <code>:invalid_password</code>.</p>

<h5>Authenticated User Exists</h5>

<p>If the passed-in <code>current_user</code> is a User Entity <em>other than</em> the specified <code>user</code> Entity <em>or</em> the Guest User, no match will be attempted, and the method will yield a call to the block&#39;s <code>result.failure</code> block with a <code>code:</code> value of <code>:illegal_current_user</code>.</p>

<h5>Guest User Attempts Authentication</h5>

<p>While no Authenticated Member currently exists (as shown by the <code>session[:current_user]</code> having a value of either <code>nil</code> or the Guest User), supplying <em>the Guest User</em> as the User Entity to be Authenticated will yield a call to the block&#39;s <code>result.failure</code> block with a <code>code:</code> value of <code>:user_is_guest</code>.</p>

<h4>Other Notes</h4>

<p>This method <strong>does not</strong> interact with a Repository, and therefore doesn&#39;t need to account for an invalid User Name parameter, for instance. Nor does it directly modify session data, although the associated Controller Action Class code <strong>must</strong> set <code>session[:current_user]</code> and <code>session[:start_time]</code> as below. This is to support extraction of this code (along with anything else not using <code>Hanami::Controller</code>-dependent input validation, redirects, flash messages, etc) to an Interactor, into which would be explicitly passed <code>session[:current_user]</code>.</p>

<p>On <em>success</em>, the Controller Action Class calling code <strong>must</strong> set:</p>

<ul>
<li><code>session[:start_time]</code> to the current time as returned by <code>Time.now</code>; and</li>
<li><code>session[:current_user]</code> to the <em>Entity</em> (not the ID value from the Repository) for the newly-Authenticated User.  This is to eliminate repeated reads of the Repository.</li>
</ul>

<p>On <em>failure</em>, the Controller Action Class calling code <strong>must</strong> set:</p>

<ul>
<li><code>session[:start_time]</code> to some sufficiently-past time to <em>always</em> trigger <code>#session_expired?</code>; <code>Hanami::Utils::Kernel.Time(0)</code> does this quite well, returning midnight GMT on 1 January 1970, converted to local time.</li>
<li><code>session[:current_user]</code> to <code>nil</code> or to the Guest User (see <a href="#configuration"><em>Configuration</em></a>).</li>
</ul>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h3>Signing Out</h3>

<h4>Overview</h4>

<p>Method involved:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>module</span> <span class='const'><span class='object_link'><a href="CryptIdent.html" title="CryptIdent (module)">CryptIdent</a></span></span>
  <span class='kw'>def</span> <span class='id identifier rubyid_sign_out'>sign_out</span><span class='lparen'>(</span><span class='label'>current_user:</span><span class='rparen'>)</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Signing out any previously Authenticated User is straightforward: call the <code>sign_out</code> method, passing in that User as the <code>current_user:</code> parameter. As with the earlier methods, this method also <strong>requires</strong> a block which accepts a <code>result</code> parameter and has <code>result.success</code> and <code>result.failure</code> calls/blocks. The <code>result.success</code> block is yielded the currently active <a href="#configuration"><em>Configuration</em></a> as a <code>config:</code> parameter, which is primarily useful if you wish to access the <code>config.success_key</code> or <code>config.error_key</code> values for setting Flash messages and so on.</p>

<p>Note that, as of Release 0.1.0, the method simply passes control to the (required) block, in whose <code>result.success</code> call block you can delete or reset <code>session[:current_user]</code> and <code>session[:start_time]</code>. We <strong>recommend</strong> reset values of:</p>

<ul>
<li><code>CryptIdent.configure_crypt_ident.guest_user</code> for <code>session[:current_user]</code> and</li>
<li><code>Hanami::Utils::Kernel.Time(0)</code> for <code>session[:start_time]</code>, which will set the timestamp to 1 January 1970 at midnight  -- a value which should *farÂ° exceed your session-expiry limit</li>
</ul>

<p>if you decide not to simply delete the previous values by assigning <code>nil</code> to them.</p>

<p>The required <code>result.failure</code> block can simply be skipped, as</p>

<pre class="code ruby"><code class="ruby">    <span class='id identifier rubyid_result'>result</span><span class='period'>.</span><span class='id identifier rubyid_failure'>failure</span> <span class='lbrace'>{</span> <span class='kw'>next</span> <span class='rbrace'>}</span>
</code></pre>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h3>Password Change</h3>

<h4>Overview</h4>

<p>Method involved:</p>

<pre class="code ruby"><code class="ruby">  <span class='kw'>module</span> <span class='const'><span class='object_link'><a href="CryptIdent.html" title="CryptIdent (module)">CryptIdent</a></span></span>
    <span class='kw'>def</span> <span class='id identifier rubyid_change_password'>change_password</span><span class='lparen'>(</span><span class='id identifier rubyid_user'>user</span><span class='comma'>,</span> <span class='id identifier rubyid_current_password'>current_password</span><span class='comma'>,</span> <span class='id identifier rubyid_new_password'>new_password</span><span class='comma'>,</span> <span class='label'>repo:</span> <span class='kw'>nil</span><span class='rparen'>)</span>
      <span class='comment'># ...
</span>    <span class='kw'>end</span>
  <span class='kw'>end</span>
</code></pre>

<p>To change an Authenticated User&#39;s password, an Entity for that User, the current Clear-Text Password, and the new Clear-Text Password are required. The method accepts an optional <code>repo</code> parameter to specify a Repository instance to which the updated User Entity should be persisted; if none is specified (i.e., if the parameter has its default value of <code>nil</code>), then the <code>repository</code> specified in the <a href="#configuration"><em>Configuration</em></a> settings is used.</p>

<h4>Successfully Changing the Password</h4>

<p>If all parameters are valid and the updated User is successfully persisted, the method calls the <strong>required</strong> block with a <code>result</code> whose <code>result.success</code> matcher is yielded a <code>user:</code> parameter with the updated User as its value. From that point, the User is able to Sign In using the User Name and updated Clear-Text Password.</p>

<p>Client code <strong>must</strong> take care not to try to Authenticate using the Encrypted Password in the Entity passed in to this method, as it is no longer current. Either retain the returned User Entity from the method, or read it again from the Repository.</p>

<h4>Error Conditions</h4>

<h5>Specified User is Guest User</h5>

<p>If the passed-in <code>user</code> is the Guest User (or <code>nil</code>), the method  calls the <strong>required</strong> block with a <code>result</code> whose <code>result.failure</code> matcher is yielded a <code>code:</code> of <code>:invalid_user</code>. No new Entity with updated values is created; no changes are made to the Repository.</p>

<h5>Invalid Current Clear-Text Password</h5>

<p>If the specified Current Clear-Text Password cannot Authenticate against the encrypted value within the <code>user</code> Entity, the method calls the <strong>required</strong> block with a <code>result</code> whose <code>result.failure</code> matcher is yielded a <code>code:</code> of <code>:bad_password</code>. No new Entity with updated values is created; no changes are made to the Repository.</p>

<h3>Generate Password Reset Token and Password Reset: Introduction</h3>

<p>Password Reset Tokens are useful for verifying that the person requesting a Password Reset for an existing User is sufficiently likely to be the person who Registered that User or, if not, that no compromise or other harm is done.</p>

<p>Typically, this is done by sending a link through email or other such medium to the address previously associated with the User purportedly requesting the Password Reset. <code>CryptIdent</code> <em>does not</em> automate generation or sending of the email message. What it <em>does</em> provide is a method to generate a new Password Reset Token to be embedded into such a message, often in the form of an HTML anchor link within an email that you construct. It also provides another method (<code>#reset_password</code>) to actually change the password given a valid, correct token.</p>

<p>It also implements an expiry system, such that if the confirmation of the Password Reset request is not completed within a <a href="#Configuration">configurable</a> time, that the token is no longer valid (and cannot be later reused by unauthorised persons).</p>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h3>Generate Password Reset Token</h3>

<p>Method involved:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>module</span> <span class='const'><span class='object_link'><a href="CryptIdent.html" title="CryptIdent (module)">CryptIdent</a></span></span>
  <span class='kw'>def</span> <span class='id identifier rubyid_generate_reset_token'>generate_reset_token</span><span class='lparen'>(</span><span class='id identifier rubyid_user_name'>user_name</span><span class='comma'>,</span> <span class='label'>repo:</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='label'>current_user:</span> <span class='kw'>nil</span><span class='rparen'>)</span>
    <span class='comment'># ...
</span>  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h4>Successfully Generating a Token</h4>

<p>Given a <code>user_name</code> parameter that specifies an existing User Name, and a <code>current_user:</code> parameter that is either <code>nil</code> or the Guest User, the method calls the <strong>required</strong> block with a <code>result</code> whose <code>result.success</code> matcher is yielded a <code>user:</code> parameter with a User Entity as its value. That User will be an Entity whose <code>name</code> matches the specified <code>user_name</code> parameter, with (new) values for the <code>token</code> and <code>password_reset_expires_at</code> attributes. The <code>token</code> attribute uniquely identifies the Password Reset request, and the <code>password_reset_expires_at</code> attribute is based on both the current (server-local) time when the updated User Entity was persisted to the Repository, and the <code>:reset_expiry</code> attribute of the configuration.</p>

<h4>Error Conditions</h4>

<h5>Authenticated User Exists</h5>

<p>If the specified <code>current_user:</code> parameter is a valid User Entity, then that is presumed to be the Current User of the Application. Authenticated Users are prohibited from requesting Password Resets for other Users; if they wish to change their <em>own</em> Clear-Text Password, there&#39;s a <a href="#password-change">method</a> for that.</p>

<p>In this case, the <strong>required</strong> block will be passed a <code>result</code> whose <code>result.failure</code> matcher is yielded a <code>code:</code> parameter of <code>:user_logged_in</code>, a <code>current_user:</code> parameter matching the passed-in User Entity, and a <code>name:</code> parameter of <code>:unassigned</code> (which must be included in the block parameters but can be ignored thereafter).</p>

<h5>Named User Not Found in Repository</h5>

<p>If the specified <code>user_name</code> parameter value does not match the <code>name</code> of any User in the Repository, then the <strong>required</strong> block will be passed a <code>result</code> whose <code>result.failure</code> matcher is yielded a <code>code:</code> parameter of <code>:user_not_found</code>, a <code>current_user:</code> parameter of the Guest User, and a <code>name:</code> parameter whose value is the passed-in <code>user_name</code> value.</p>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h3>Password Reset</h3>

<h4>Overview</h4>

<p>Method involved:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>module</span> <span class='const'><span class='object_link'><a href="CryptIdent.html" title="CryptIdent (module)">CryptIdent</a></span></span>
  <span class='kw'>def</span> <span class='id identifier rubyid_reset_password'>reset_password</span><span class='lparen'>(</span><span class='id identifier rubyid_token'>token</span><span class='comma'>,</span> <span class='id identifier rubyid_new_password'>new_password</span><span class='comma'>,</span> <span class='label'>repo:</span> <span class='kw'>nil</span><span class='comma'>,</span> <span class='label'>current_user:</span> <span class='kw'>nil</span><span class='rparen'>)</span>
  <span class='kw'>end</span> 
<span class='kw'>end</span>
</code></pre>

<p>Calling <code>#reset_password</code> is different than calling <code>#change_password</code> in one vital respect: with <code>#change_password</code>, the User involved <strong>must</strong> be the Current User (as presumed by passing the appropriate User Entity in as the <code>current_user:</code> parameter), whereas <code>#reset_password</code> <strong>must not</strong> be called with <em>any</em> User other than the Guest User as the <code>current_user:</code> parameter (and, again presumably, the Current User for the session). How can we assure ourselves that the request is legitimate for a specific User? By use of the Token generated by a previous call to <code>#generate_reset_token</code>, which is used <em>in place of</em> a User Name for this request.</p>

<h4>Successfully Resetting a Password</h4>

<p>To successfully perform a Password Reset, supply a valid, non-expired Token along with a new Clear-Text Password to the <code>#reset_password</code> method. Once the Token is found in the Repository specified by the <code>repo:</code> parameter (or in the configuration-default Repository if the default value of <code>nil</code> is used for <code>repo:</code>), and is verified not to have Expired, then the Repository will be updated with a record for that User where the <code>password_hash</code> field has been updated to reflect the new Clear-Text Password, and the <code>token</code> and <code>password_reset_expires_at</code> fields will be set to <code>nil</code>. </p>

<p>If all the preceding is successful and the updated User is successfully persisted, the method calls the <strong>required</strong> block with a <code>result</code> whose <code>result.success</code> matcher is yielded a <code>user:</code> parameter with the updated User as its value. From that point, the User is able to Sign In using the User Name and updated Clear-Text Password.</p>

<p>Client code <strong>must</strong> take care not to try to Authenticate using the Encrypted Password in the Entity passed in to this method, as it is no longer current. Either retain the returned User Entity from the method, or read it again from the Repository.</p>

<h4>Error Conditions</h4>

<h5>Expired Token</h5>

<p>If the passed-in <code>token</code> parameter matches the <code>token</code> field of a record in the Repository <em>and</em> that Token is determined to have Expired, then this method calls the <strong>required</strong> block with a <code>result</code> whose <code>result.failure</code> matcher is yielded a <code>code:</code> parameter of <code>:expired_token</code>; a <code>config:</code> parameter of the active <a href="#configuration"><em>Configuration</em></a> (including the Repository used to retrieve the relevant User record); and a <code>token:</code> parameter that has the same value as the passed-in <code>token</code> parameter.</p>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h5>Token Not Found</h5>

<p>If the passed-in <code>token</code> parameter <em>does not</em> match the <code>token</code> field of any record in the Repository, then this method calls the <strong>required</strong> block with a <code>result</code> whose <code>result.failure</code> matcher is yielded a <code>code:</code> parameter of <code>:token_not_found</code>; a <code>config:</code> parameter of the active <a href="#configuration"><em>Configuration</em></a> (including the Repository used in the failed attempt to retrieve the relevant User record); and a <code>token:</code> parameter that has the same value as the passed-in <code>token</code> parameter.</p>

<h5>Invalid Current User</h5>

<p>If the passed-in <code>current_user:</code> parameter <em>is not</em> either the default <code>nil</code> or the Guest User, then this method calls the <strong>required</strong> block with a <code>result</code> whose <code>result.failure</code> matcher is yielded a <code>code:</code> parameter of <code>:invalid_current_user</code>; a <code>config:</code> parameter of the active <a href="#configuration"><em>Configuration</em></a> (including the Repository used in the failed attempt to retrieve the relevant User record); and a <code>token:</code> parameter that has the same value as the passed-in <code>token</code> parameter.</p>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h3>Session Management Overview</h3>

<p>Session management is a necessary part of implementing authentication (and authorisation) within an app. However,  it&#39;s not something that an authentication <em>library</em> can fully implement without making the client application excessively inflexible and brittle.</p>

<p><code>CryptIdent</code> has two convenience methods which <em>help in</em> implementing session-expiration logic; these make use of the <code>session_expiry</code> <a href="#configuration">configuration value</a>.</p>

<ul>
<li><code>CryptIdent#update_session_expiry</code> returns a <code>Hash</code> whose <code>:expires_at</code> value the current time <em>plus</em> the number of seconds specified by the <code>session_expiry</code> configuration value. This can be used to update the corresponding <code>session</code> data which defines the session-expiry time;</li>
<li><code>CryptIdent#session_expired?</code> returns <code>true</code> if the current time is not less than the session-expiry time; it returns <code>false</code> otherwise.</li>
</ul>

<p>Example code which uses these methods is illustrated below, as a shared-code module that may be included in your controllers&#39; action classes:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># apps/web/controllers/handle_session.rb
</span>
<span class='kw'>module</span> <span class='const'>Web</span>
  <span class='kw'>module</span> <span class='const'>HandleSession</span>
    <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="CryptIdent.html" title="CryptIdent (module)">CryptIdent</a></span></span>

    <span class='kw'>def</span> <span class='kw'>self</span><span class='period'>.</span><span class='id identifier rubyid_included'>included</span><span class='lparen'>(</span><span class='id identifier rubyid_other'>other</span><span class='rparen'>)</span>
      <span class='id identifier rubyid_other'>other</span><span class='period'>.</span><span class='id identifier rubyid_class_eval'>class_eval</span> <span class='kw'>do</span>
        <span class='id identifier rubyid_before'>before</span> <span class='symbol'>:validate_session</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>

    <span class='id identifier rubyid_private'>private</span>

    <span class='kw'>def</span> <span class='id identifier rubyid_validate_session'>validate_session</span>
      <span class='id identifier rubyid_updates'>updates</span> <span class='op'>=</span> <span class='id identifier rubyid_update_session_expiry'>update_session_expiry</span><span class='lparen'>(</span><span class='id identifier rubyid_session'>session</span><span class='rparen'>)</span>
      <span class='kw'>if</span> <span class='op'>!</span><span class='id identifier rubyid_session_expired?'>session_expired?</span><span class='lparen'>(</span><span class='id identifier rubyid_session'>session</span><span class='rparen'>)</span>
        <span class='id identifier rubyid_session'>session</span><span class='lbracket'>[</span><span class='symbol'>:expires_at</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='id identifier rubyid_updates'>updates</span><span class='lbracket'>[</span><span class='symbol'>:expires_at</span><span class='rbracket'>]</span>
        <span class='kw'>return</span>
      <span class='kw'>end</span>

      <span class='ivar'>@redirect_url</span> <span class='op'>||=</span> <span class='id identifier rubyid_routes'>routes</span><span class='period'>.</span><span class='id identifier rubyid_root_path'>root_path</span>
      <span class='id identifier rubyid_session'>session</span><span class='lbracket'>[</span><span class='symbol'>:current_user</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_guest_user'>guest_user</span>
      <span class='id identifier rubyid_session'>session</span><span class='lbracket'>[</span><span class='symbol'>:expires_at</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='id identifier rubyid_updates'>updates</span><span class='lbracket'>[</span><span class='symbol'>:expires_at</span><span class='rbracket'>]</span>
      <span class='id identifier rubyid_error_message'>error_message</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Your session has expired. You have been signed out.</span><span class='tstring_end'>&#39;</span></span>
      <span class='id identifier rubyid_flash'>flash</span><span class='lbracket'>[</span><span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_error_key'>error_key</span><span class='rbracket'>]</span> <span class='op'>=</span> <span class='id identifier rubyid_error_message'>error_message</span>
      <span class='id identifier rubyid_redirect_to'>redirect_to</span> <span class='ivar'>@redirect_url</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>This code should be fairly self-explanatory. Including the module adds the private <code>#validate_session</code> method to the client controller action class, adding a call to that method before the action class&#39; <code>#call</code> method is entered. If the session-expiry time has been previously set and is not before the current time, then that session-expiry time is reset based on the current time, and no further action is taken. Otherwise:</p>

<ol>
<li>The <code>current_user</code> setting in the session data is overwritten with the <a href="#configuration"><code>config.guest_user</code></a> value (defaulting to <code>nil</code>);</li>
<li>A flash error message is set, which <strong>should</strong> be rendered within the controller action&#39;s view; and</li>
<li>Control is redirected to the path or URL specified by <code>@redirect_url</code>, defaulting to the root path (<code>/</code>).</li>
</ol>

<p>This code will be instantly familiar to anyone coming from another framework like Rails, where the conventional way to ensure authentication before a controller action is executed is to add a <code>:before</code> hook. Adding this module to the controller action class is also justifiable Hanami, since it depends on and interacts with session data. (Just don&#39;t let any actual domain logic <a href="http://hanamirb.org/guides/1.2/actions/control-flow/#proc">taint</a> your controller callbacks; that&#39;s begging for difficult-to-debug problems going forward.</p>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h3>Session Expired</h3>

<p>Method involved:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>module</span> <span class='const'><span class='object_link'><a href="CryptIdent.html" title="CryptIdent (module)">CryptIdent</a></span></span>
  <span class='kw'>def</span> <span class='id identifier rubyid_session_expired?'>session_expired?</span><span class='lparen'>(</span><span class='id identifier rubyid_session_data'>session_data</span><span class='op'>=</span><span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span>
    <span class='comment'># ...
</span>  <span class='kw'>end</span> 
<span class='kw'>end</span>
</code></pre>

<p>This is one of two methods in <code>CryptIdent</code> (the other being <a href="#update-session-expiry"><code>#update_session_expiry</code></a>, below) which <em>does not</em> follow the <code>result</code>/success/failure <a href="#interfaces">monad workflow</a>. Like that method:</p>

<ul>
<li>there is no success/failure division in the workflow;</li>
<li>calling this method only makes sense if there is an Authenticated User;</li>
<li>it is intended for use in session-management code as described in the <a href="#session-management-overview">Overview</a> above.</li>
</ul>

<p>All this method does is check an instance variable, <code>@_ci_session_expiry_at</code>, added to the including class when the module is <code>include</code>d in the client-code class or module, returning <code>true</code> if it is <em>less than</em> the value of <code>Time.now</code> and <code>false</code> otherwise.</p>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h3>Update Session Expiry</h3>

<h4>Overview</h4>

<p>Method involved:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>module</span> <span class='const'><span class='object_link'><a href="CryptIdent.html" title="CryptIdent (module)">CryptIdent</a></span></span>
  <span class='kw'>def</span> <span class='id identifier rubyid_update_session_expiry'>update_session_expiry</span><span class='lparen'>(</span><span class='id identifier rubyid_session_data'>session_data</span><span class='op'>=</span><span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span>
    <span class='comment'># ...
</span>  <span class='kw'>end</span> 
<span class='kw'>end</span>
</code></pre>

<p>This is one of two methods in <code>CryptIdent</code> (the other being <a href="#session-expired"><code>#session_expired?</code></a>, above) which <em>does not</em> follow the <code>result</code>/success/failure <a href="#interfaces">monad workflow</a>. This is because there is no success/failure division in the workflow. Calling the method only makes sense if there is an Authenticated User, but <em>all this method does</em> is return a <code>Hash</code> as defined below.</p>

<p>It is intended for use in session-management code as described in the <a href="#session-management-overview">Overview</a> above.</p>

<h4>Parameter</h4>

<p>The parameter, <code>session_data</code>, is a Hash-like object which <strong>should</strong> have existing entries for <code>:current_user</code> (defaulting to the Guest User if not found) and for <code>:expires_at</code> (defaulting to the <a href="https://en.wikipedia.org/wiki/Unix_time">epoch</a> if not found).</p>

<h4>Return</h4>

<p>The return value is a <code>Hash</code> which:</p>

<ol>
<li><code>:current_user</code> value is the same as the passed-in parameter&#39;s <code>:current_user</code> value <em>if</em> that is a Registered User, or the Guest User if it isn&#39;t; and</li>
<li><code>:expires_at</code> value is a <code>Time</code> instance based on the current time when called, added to the <a href="#configuration">configured</a> <code>session_expiry</code> value.</li>
</ol>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h1>API Documentation</h1>

<p>See <a href="./docs/index.html">the Documentation Index</a></p>

<h1>Development</h1>

<p>After checking out the repo, run <code>bin/setup</code> to install dependencies. If you use <a href="https://github.com/rbenv/rbenv"><code>rbenv</code></a> and <a href="https://github.com/jf/rbenv-gemset"><code>rbenv-gemset</code></a>, the <code>setup</code> script will create a new Gemset (in <code>./tmp/gemset</code>) to keep your system Gem repository pristine. Then, run <code>bin/rake test</code> to run the tests, or <code>bin/rake</code> without arguments to run tests and all static-analysis tools (<a href="https://github.com/seattlerb/flog">Flog</a>, <a href="https://github.com/seattlerb/flay">Flay</a>, <a href="https://github.com/troessner/reek">Reek</a>, and <a href="https://github.com/rubocop-hq/rubocop/">RuboCop</a>). Running <code>bin/rake inch</code> will let <a href="http://trivelop.de/inch/">Inch</a> comment on the amount of internal documentation in the project.</p>

<p>You can also run <code>bin/console</code> for an interactive prompt that will allow you to experiment.</p>

<p>To install this gem onto your local machine, run <code>bin/rake install</code> or <code>bundle exec rake install</code>. To release a new version, update the version number in <code>version.rb</code>, and then run <code>bin/rake release</code> or <code>bundle exec rake release</code>, which will create a Git tag for the version, push Git commits and tags, and push the <code>.gem</code> file to <a href="https://rubygems.org">rubygems.org</a>.</p>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h1>Contributing</h1>

<p>Bug reports and pull requests are welcome on GitHub at <a href="https://github.com/jdickey/crypt_ident">https://github.com/jdickey/crypt_ident</a>. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the <a href="http://contributor-covenant.org">Contributor Covenant</a> code of conduct.</p>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h1>License</h1>

<p>The gem is available as open source under the terms of the <a href="https://opensource.org/licenses/MIT">MIT License</a>.</p>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>

<h1>Code of Conduct</h1>

<p>Everyone interacting in the CryptIdent projectâs codebases, issue trackers, chat rooms and mailing lists is expected to follow the <a href="https://github.com/jdickey/crypt_ident/blob/master/CODE_OF_CONDUCT.md">code of conduct</a>.</p>

<p><sub style="font-size: 0.75rem;"><a href="#CryptIdent">Back to Top</a></sub></p>
</div></div>

      <div id="footer">
  Generated on Sun Dec 16 15:42:48 2018 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.16 (ruby-2.5.3).
</div>

    </div>
  </body>
</html>